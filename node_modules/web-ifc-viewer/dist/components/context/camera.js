import { PerspectiveCamera, Vector3, MOUSE, Box3, MathUtils } from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls';
import { IfcComponent } from '../../base-types';
export class IfcCamera extends IfcComponent {
    constructor(context) {
        super(context);
        this.previousScale = 0;
        this.moveForward = false;
        this.moveBackward = false;
        this.moveLeft = false;
        this.moveRight = false;
        this.moveUp = false;
        this.moveDown = false;
        this.prevTime = performance.now();
        this.velocity = new Vector3();
        this.direction = new Vector3();
        this.onKeyDown = (event) => {
            // eslint-disable-next-line default-case
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    this.moveForward = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    this.moveLeft = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    this.moveBackward = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    this.moveRight = true;
                    break;
                case 'KeyF':
                    this.moveUp = true;
                    break;
                case 'KeyR':
                    this.moveDown = true;
                    break;
            }
        };
        this.onKeyUp = (event) => {
            // eslint-disable-next-line default-case
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    this.moveForward = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    this.moveLeft = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    this.moveBackward = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    this.moveRight = false;
                    break;
                case 'KeyF':
                    this.moveUp = false;
                    break;
                case 'KeyR':
                    this.moveDown = false;
                    break;
            }
        };
        this.context = context;
        const dims = this.context.getDimensions();
        this.ifcCamera = new PerspectiveCamera(45, dims.x / dims.y, 0.1, 1000);
        this.setupCamera();
        this.orbitControls = new OrbitControls(this.camera, context.getDomElement());
        this.controls = new PointerLockControls(this.camera, context.getDomElement());
        this.context.getScene().add(this.fpControls.getObject());
        this.setupOrbitControls();
        document.addEventListener('keydown', this.onKeyDown);
        document.addEventListener('keyup', this.onKeyUp);
        document.addEventListener('click', () => this.fpControls.lock());
    }
    get target() {
        return this.orbitControls.target;
    }
    update(_delta) {
        // this.orbitControls.update();
        const time = performance.now();
        if (this.fpControls.isLocked) {
            const delta = (time - this.prevTime) / 1000;
            this.velocity.z -= this.velocity.z * 10.0 * delta;
            this.velocity.x -= this.velocity.x * 10.0 * delta;
            this.velocity.y -= this.velocity.y * 10.0 * delta;
            this.direction.z = Number(this.moveForward) - Number(this.moveBackward);
            this.direction.x = Number(this.moveRight) - Number(this.moveLeft);
            this.direction.y = Number(this.moveUp) - Number(this.moveDown);
            this.direction.normalize(); // this ensures consistent movements in all directions
            if (this.moveForward || this.moveBackward) {
                this.velocity.z -= this.direction.z * 400.0 * delta;
            }
            if (this.moveLeft || this.moveRight) {
                this.velocity.x -= this.direction.x * 400.0 * delta;
            }
            if (this.moveUp || this.moveDown) {
                this.velocity.y -= this.direction.y * 400.0 * delta;
            }
            this.fpControls.moveRight(-this.velocity.x * delta);
            this.fpControls.moveForward(-this.velocity.z * delta);
            this.fpControls.getObject().position.y += this.velocity.y * delta; // new behavior
        }
        this.prevTime = time;
    }
    updateAspect() {
        const dims = this.context.getDimensions();
        this.camera.aspect = dims.x / dims.y;
        this.camera.updateProjectionMatrix();
    }
    toggleControls(active) {
        this.orbitControls.enabled = active;
    }
    targetItem(mesh, useScaleFactor = true, limit = 3) {
        const center = this.context.getCenter(mesh);
        const target = this.orbitControls.target;
        let offset = new Vector3().subVectors(this.camera.position, target);
        if (useScaleFactor) {
            offset = this.applyScaleToFocus(mesh, offset, limit);
        }
        const endPosition = new Vector3().addVectors(offset, center);
        this.context.getAnimator().move(target, center);
        this.context.getAnimator().move(this.camera.position, endPosition);
    }
    fitModelToFrame() {
        const scene = this.context.getScene();
        const box = new Box3().setFromObject(scene.children[scene.children.length - 1]);
        const boxSize = box.getSize(new Vector3()).length();
        const boxCenter = box.getCenter(new Vector3());
        const halfSizeToFitOnScreen = boxSize * 0.5;
        const halfFovY = MathUtils.degToRad(this.camera.fov * 0.5);
        const distance = halfSizeToFitOnScreen / Math.tan(halfFovY);
        const direction = new Vector3()
            .subVectors(this.camera.position, boxCenter)
            .multiply(new Vector3(1, 0, 1))
            .normalize();
        this.camera.position.copy(direction.multiplyScalar(distance).add(boxCenter));
        this.camera.updateProjectionMatrix();
        this.camera.lookAt(boxCenter.x, boxCenter.y, boxCenter.z);
        // set target to newest loaded model
        this.orbitControls.target.copy(boxCenter);
        this.orbitControls.update();
    }
    setupCamera() {
        this.camera.position.z = 8;
        this.camera.position.y = 8;
        this.camera.position.x = 8;
        this.camera.lookAt(new Vector3(0, 0, 0));
    }
    setupOrbitControls() {
        this.orbitControls.enableDamping = true;
        this.orbitControls.dampingFactor *= 2;
        const panWithMMB = this.context.options.panWithMMB || true;
        if (panWithMMB) {
            this.orbitControls.mouseButtons = {
                RIGHT: MOUSE.RIGHT,
                MIDDLE: MOUSE.RIGHT,
                LEFT: MOUSE.LEFT
            };
        }
    }
    applyScaleToFocus(mesh, offset, limit) {
        const scale = this.getMeshScale(mesh, limit);
        if (this.previousScale !== 0) {
            offset = offset.multiplyScalar(scale / this.previousScale);
        }
        this.previousScale = scale;
        return offset;
    }
    getMeshScale(mesh, limit) {
        var _a;
        const scaleVector = new Vector3();
        (_a = mesh.geometry.boundingBox) === null || _a === void 0 ? void 0 : _a.getSize(scaleVector);
        const scale = scaleVector.length();
        if (this.previousScale === 0)
            return scale;
        if (scale > this.previousScale * limit)
            return this.previousScale * limit;
        if (scale < this.previousScale / limit)
            return this.previousScale / limit;
        return scale;
    }
}
//# sourceMappingURL=camera.js.map