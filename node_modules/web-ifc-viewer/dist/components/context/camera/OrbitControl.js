import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { Box3, MathUtils, MOUSE, Vector3 } from 'three';
import { CameraProjections, IfcComponent, NavigationModes } from '../../../base-types';
import { LiteEvent } from '../../../utils/LiteEvent';
export class OrbitControl extends IfcComponent {
    constructor(context, perspectiveCamera, orthographicCamera) {
        super(context);
        this.context = context;
        this.perspectiveCamera = perspectiveCamera;
        this.orthographicCamera = orthographicCamera;
        this.enabled = true;
        this.mode = NavigationModes.Orbit;
        this.onChange = new LiteEvent();
        this.onUnlock = new LiteEvent();
        this.onChangeProjection = new LiteEvent();
        this.currentTarget = new Vector3();
        this.onlyPanningAllowed = false;
        this.startView = {
            target: new Vector3(),
            camera: new Vector3(20, 20, 20)
        };
        this.targetItem = (mesh, duration) => {
            const center = this.context.getCenter(mesh);
            const cameraEnd = new Vector3()
                .subVectors(this.perspectiveCamera.position, this.currentTarget)
                .add(center);
            this.context.getAnimator().move(this.perspectiveCamera.position, cameraEnd, duration);
            this.context.getAnimator().move(this.orbitControls.target, center, duration);
        };
        this.currentCamera = this.perspectiveCamera;
        this.orbitControls = new OrbitControls(this.perspectiveCamera, context.getDomElement());
        // this.orbitControls.minDistance = 1;
        // this.orbitControls.maxDistance = 500;
        // this.orbitControls.minZoom = 1;
        // this.orbitControls.maxZoom = 500;
        this.orbitControls.addEventListener('change', (event) => {
            this.currentTarget.copy(this.orbitControls.target);
            this.onChange.trigger(event);
        });
        this.setupOrbitControls();
    }
    get activeCamera() {
        return this.orbitControls.object;
    }
    get target() {
        return this.orbitControls.target;
    }
    get panOnlyMode() {
        return this.onlyPanningAllowed;
    }
    set panOnlyMode(active) {
        this.onlyPanningAllowed = active;
        this.orbitControls.enableRotate = !active;
    }
    set minDistance(min) {
        this.orbitControls.minDistance = min;
    }
    set maxDistance(max) {
        this.orbitControls.maxDistance = max;
    }
    set homeView({ camera, target }) {
        this.startView.camera = camera;
        this.startView.target = target;
    }
    get projection() {
        return this.activeCamera === this.perspectiveCamera
            ? CameraProjections.Perspective
            : CameraProjections.Orthographic;
    }
    set projection(projection) {
        if (this.projection === projection)
            return;
        if (projection === CameraProjections.Orthographic) {
            // Matching orthographic camera to perspective camera
            // Resource: https://stackoverflow.com/questions/48758959/what-is-required-to-convert-threejs-perspective-camera-to-orthographic
            const lineOfSight = new Vector3();
            this.perspectiveCamera.getWorldDirection(lineOfSight);
            const distance = this.target.clone().sub(this.perspectiveCamera.position);
            const depth = distance.dot(lineOfSight);
            const dims = this.context.getDimensions();
            const aspect = dims.x / dims.y;
            const height = depth * 2 * Math.atan((this.perspectiveCamera.fov * (Math.PI / 180)) / 2);
            const width = height * aspect;
            this.orthographicCamera.zoom = 1;
            this.orthographicCamera.left = width / -2;
            this.orthographicCamera.right = width / 2;
            this.orthographicCamera.top = height / 2;
            this.orthographicCamera.bottom = height / -2;
            this.orthographicCamera.updateProjectionMatrix();
            this.orthographicCamera.position.copy(this.perspectiveCamera.position);
            this.orthographicCamera.quaternion.copy(this.perspectiveCamera.quaternion);
            this.orbitControls.object = this.orthographicCamera;
            this.currentCamera = this.orthographicCamera;
        }
        else {
            this.perspectiveCamera.position.copy(this.orthographicCamera.position);
            this.perspectiveCamera.quaternion.copy(this.orthographicCamera.quaternion);
            this.perspectiveCamera.updateProjectionMatrix();
            this.orbitControls.object = this.perspectiveCamera;
            this.currentCamera = this.perspectiveCamera;
        }
    }
    setOrbitControlsButtons(buttons) {
        this.orbitControls.mouseButtons = {
            LEFT: buttons.left,
            MIDDLE: buttons.middle,
            RIGHT: buttons.right
        };
    }
    update(_delta) {
        if (this.enabled) {
            this.orbitControls.update();
        }
    }
    /**
     * @deprecated Use onChange.on() instead.
     */
    submitOnChange(action) {
        this.onChange.on(action);
    }
    /**
     * @deprecated Use onChange.on() instead.
     */
    submitOnUnlock(action) {
        this.onUnlock.on(action);
    }
    toggleProjection() {
        if (this.activeCamera === this.perspectiveCamera) {
            this.projection = CameraProjections.Orthographic;
        }
        else {
            this.projection = CameraProjections.Perspective;
        }
        this.onChangeProjection.trigger(this.activeCamera);
    }
    toggle(active, options) {
        const preventAdjustment = options !== undefined && options.preventOrbitAdjustment;
        if (active && !preventAdjustment) {
            this.adjustTarget();
        }
        this.enabled = active;
        this.orbitControls.enabled = active;
    }
    goTo(position, target, duration) {
        this.context.getAnimator().move(this.currentCamera.position, position, duration);
        this.context.getAnimator().move(this.orbitControls.target, target, duration);
    }
    goToHomeView() {
        this.context.getAnimator().move(this.perspectiveCamera.position, this.startView.camera);
        this.context.getAnimator().move(this.orbitControls.target, this.startView.target);
    }
    fitModelToFrame() {
        if (!this.enabled)
            return;
        const { boxCenter, distance } = this.getBoxCenterAndDistance();
        const direction = new Vector3()
            .subVectors(this.perspectiveCamera.position, boxCenter)
            .multiply(new Vector3(1, 0, 1))
            .normalize();
        this.perspectiveCamera.position.copy(direction.multiplyScalar(distance).add(boxCenter));
        this.perspectiveCamera.updateProjectionMatrix();
        this.orbitControls.target.set(boxCenter.x, boxCenter.y, boxCenter.z);
    }
    getBoxCenterAndDistance() {
        const scene = this.context.getScene();
        const box = new Box3().setFromObject(scene.children[scene.children.length - 1]);
        const boxSize = box.getSize(new Vector3()).length();
        const boxCenter = box.getCenter(new Vector3());
        const halfSizeToFitOnScreen = boxSize * 0.5;
        const halfFovY = MathUtils.degToRad(this.perspectiveCamera.fov * 0.5);
        const distance = halfSizeToFitOnScreen / Math.tan(halfFovY);
        return { boxCenter, distance };
    }
    adjustTarget() {
        const cameraDir = new Vector3();
        this.activeCamera.getWorldDirection(cameraDir);
        cameraDir.multiplyScalar(20);
        const center = new Vector3().addVectors(cameraDir, this.activeCamera.position);
        this.orbitControls.target.set(center.x, center.y, center.z);
    }
    setupOrbitControls() {
        this.orbitControls.enableDamping = true;
        this.orbitControls.dampingFactor *= 2;
        this.orbitControls.target.set(0, 0, 0);
        const panWithMMB = this.context.options.panWithMMB || true;
        if (panWithMMB) {
            this.orbitControls.mouseButtons = {
                RIGHT: MOUSE.RIGHT,
                MIDDLE: MOUSE.RIGHT,
                LEFT: MOUSE.LEFT
            };
        }
    }
}
//# sourceMappingURL=OrbitControl.js.map