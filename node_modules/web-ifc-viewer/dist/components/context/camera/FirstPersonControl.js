import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls';
import { Vector3 } from 'three';
import { CameraProjections, dimension, IfcComponent, NavigationModes } from '../../../base-types';
import { LiteEvent } from '../../../utils/LiteEvent';
export class FirstPersonControl extends IfcComponent {
    constructor(context, camera, ifcCamera) {
        super(context);
        this.enabled = false;
        this.mode = NavigationModes.FirstPerson;
        this.onChange = new LiteEvent();
        this.onUnlock = new LiteEvent();
        this.onChangeProjection = new LiteEvent();
        this.prevTime = performance.now();
        this.velocity = new Vector3();
        this.direction = new Vector3();
        this.speed = 200;
        this.keyBinding = {
            forward: {
                active: false,
                keys: ['KeyW', 'ArrowUp']
            },
            back: {
                active: false,
                keys: ['KeyS', 'ArrowDown']
            },
            right: {
                active: false,
                keys: ['KeyD', 'ArrowRight']
            },
            left: {
                active: false,
                keys: ['KeyA', 'ArrowLeft']
            },
            up: {
                active: false,
                keys: ['KeyR']
            },
            down: {
                active: false,
                keys: ['KeyF']
            }
        };
        this.controlsMap = {
            [dimension.z]: [this.keyBinding.forward, this.keyBinding.back],
            [dimension.x]: [this.keyBinding.right, this.keyBinding.left],
            [dimension.y]: [this.keyBinding.up, this.keyBinding.down]
        };
        this.dimensions = [dimension.x, dimension.y, dimension.z];
        this.onKeyDown = (event) => {
            const found = this.getControl(event);
            if (found)
                found.active = true;
        };
        this.onKeyUp = (event) => {
            const found = this.getControl(event);
            if (found)
                found.active = false;
        };
        this.ifcCamera = ifcCamera;
        this.controls = new PointerLockControls(camera, context.getDomElement());
        this.controls.addEventListener('unlock', (event) => {
            ifcCamera.setNavigationMode(NavigationModes.Orbit);
            this.onUnlock.trigger(event);
        });
        this.controls.addEventListener('change', (event) => {
            this.onChange.trigger(event);
        });
        context.getScene().add(this.controls.getObject());
    }
    get projection() {
        return CameraProjections.Perspective;
    }
    toggle(active) {
        if (active && this.ifcCamera.projection === CameraProjections.Orthographic) {
            this.ifcCamera.toggleProjection();
        }
        this.enabled = active;
        if (active)
            this.enable();
        else
            this.disable();
    }
    update(_delta) {
        if (this.enabled && this.controls.isLocked) {
            const currentTime = performance.now();
            const delta = (currentTime - this.prevTime) / 1000;
            this.move(delta);
            this.prevTime = currentTime;
        }
    }
    /**
     * @deprecated Use onChange.on() instead.
     */
    submitOnChange(action) {
        this.onChange.on(action);
    }
    /**
     * @deprecated Use onChange.on() instead.
     */
    submitOnUnlock(action) {
        this.onUnlock.on(action);
    }
    enable() {
        if (!this.controls.isLocked)
            this.controls.lock();
        document.addEventListener('keydown', this.onKeyDown);
        document.addEventListener('keyup', this.onKeyUp);
    }
    disable() {
        if (this.controls.isLocked)
            this.controls.unlock();
        document.removeEventListener('keydown', this.onKeyDown);
        document.removeEventListener('keyup', this.onKeyUp);
    }
    move(delta) {
        this.applySmoothDeceleration(delta);
        this.updateDirections();
        this.updateVelocity(delta);
        this.moveCamera(delta);
    }
    applySmoothDeceleration(delta) {
        this.dimensions.forEach((dim) => {
            this.velocity[dim] -= this.velocity[dim] * 10.0 * delta;
        });
    }
    updateDirections() {
        this.dimensions.forEach((dim) => this.updateDirection(dim));
        this.direction.normalize(); // this ensures consistent movements in all directions
    }
    updateDirection(dim) {
        const controls = this.controlsMap[dim];
        const oneDirection = controls[0];
        const oppositeDirection = controls[1];
        this.direction[dim] = Number(oneDirection.active) - Number(oppositeDirection.active);
    }
    updateVelocity(delta) {
        this.dimensions.forEach((dimension) => {
            const controls = this.controlsMap[dimension];
            const isActive = controls.find((control) => control.active);
            if (isActive) {
                this.velocity[dimension] -= this.direction[dimension] * this.speed * delta;
            }
        });
    }
    moveCamera(delta) {
        this.controls.moveRight(-this.velocity.x * delta);
        this.controls.moveForward(-this.velocity.z * delta);
        this.controls.getObject().position.y -= this.velocity.y * delta;
    }
    getControl(event) {
        const controlValues = Object.values(this.keyBinding);
        return controlValues.find((control) => control.keys.indexOf(event.code) > -1);
    }
}
//# sourceMappingURL=FirstPersonControl.js.map